# -*- coding: utf-8 -*-
"""CRYPTO_TI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ch4dpndz5xfHeYy7Y0QSjq-BF_F0_onR
"""

#pip install alpha_vantage pandas
#Your API key is: MVPD59K08DSW0ANM.

pip install alpha_vantage pandas ta

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import tensorflow as tf
sns.set() # setting seaborn default for plots
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.svm import SVC
from sklearn.feature_selection import SelectKBest, f_classif
from google.colab import files
from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
from pandas_profiling import ProfileReport
from sklearn.metrics import r2_score, accuracy_score
from sklearn.model_selection import learning_curve
from sklearn.model_selection import train_test_split
from matplotlib import style
import datetime as dt1
from datetime import datetime as dt
import plotly.graph_objs as go
from statsmodels.tsa.seasonal import seasonal_decompose
import keras
import keras.backend as K
import ta
K.clear_session()
key = 'MVPD59K08DSW0ANM'
key = '662ULMA9IRI9706B'
key = 'IEIUKL0X9WEK0E2A'
key = 'BT0IMUWGM1BO0E9P'

cut_off = 3300

"""**Extracting stock timeseries**"""

from alpha_vantage.cryptocurrencies import CryptoCurrencies
import matplotlib.pyplot as plt

cc = CryptoCurrencies(key=key, output_format='pandas')
data1, meta_data = cc.get_digital_currency_daily(symbol='BTC', market='USD')
data1 = data1.iloc[::-1]

data1['4b. close (USD)'].plot()
plt.tight_layout()
plt.title('Daily close value for bitcoin (BTC)')
plt.grid()
plt.show()
data1

from alpha_vantage.cryptocurrencies import CryptoCurrencies
import matplotlib.pyplot as plt

cc = CryptoCurrencies(key=key, output_format='pandas')
data, meta_data = cc.get_digital_currency_daily(symbol='BTC', market='USD')
#data = data.iloc[::-1]

data['4b. close (USD)'].plot()
plt.tight_layout()
plt.title('Daily close value for bitcoin (BTC)')
plt.grid()
plt.show()
data

import pandas as pd
from ta.utils import dropna
from ta.volatility import BollingerBands


# Load datas


# Initialize Bollinger Bands Indicator
indicator_bb = BollingerBands(close=data1["4b. close (USD)"], window=20, window_dev=2,fillna= True)

# Add Bollinger Bands features
#data['bb_bbm'] = indicator_bb.bollinger_mavg()
#data['bb_bbh'] = indicator_bb.bollinger_hband()
data['bb_bbl'] = indicator_bb.bollinger_lband()

# Add Bollinger Band high indicator
#data['bb_bbhi'] = indicator_bb.bollinger_hband_indicator()

# Add Bollinger Band low indicator
data['bb_bbli'] = indicator_bb.bollinger_lband_indicator()

data

data["4b. close (USD)"]

import ta
data['sma'] = ta.trend.sma_indicator(data1["4b. close (USD)"], window=14, fillna=True)
data['ema'] = ta.trend.ema_indicator(data1["4b. close (USD)"], window=14, fillna=True)
data['RSI'] = ta.momentum.rsi(data1["4b. close (USD)"], window=14, fillna=True)
data['macd'] = ta.trend.macd_diff(data1["4b. close (USD)"], window_slow=14, window_fast=12, window_sign=9, fillna=True)

data['obv'] = ta.volume.on_balance_volume(data1["4b. close (USD)"], data1["5. volume"], fillna=True)

data['vwap'] = ta.volume.volume_weighted_average_price( data1['2a. high (USD)'], data1['3a. low (USD)'], data1['4b. close (USD)'], data1['5. volume'], window = 14, fillna= True)
data['stoch'] = ta.momentum.stoch(data1['2a. high (USD)'], data1['3a. low (USD)'], data1['4b. close (USD)'], window=14, smooth_window=3, fillna=True) 
data['cci'] = ta.trend.cci(data1['2a. high (USD)'], data1['3a. low (USD)'], data1['4b. close (USD)'], window=20, constant=0.015, fillna=True)
data['adx'] = ta.trend.adx(data1['2a. high (USD)'], data1['3a. low (USD)'], data1['4b. close (USD)'], window=14, fillna=True)



data['macd']= data['macd'] / (data1["4b. close (USD)"] )
data['sma']= data['sma']/ (data1["4b. close (USD)"] )
data['ema']= data['ema']/ (data1["4b. close (USD)"] )
data['adx']= data['adx']/ (data1["4b. close (USD)"] )
data['vwap']= data['vwap']/ (data1["4b. close (USD)"] )



data.loc[data['RSI'] < 30, 'RSI'] = -1
data.loc[data['RSI'] > 70, 'RSI'] = 1
data.loc[(data['RSI'] > 30) & (data['RSI'] < 70), 'RSI'] = 0
data['RSI'].plot()

data['4a. close (USD)'].size

data['target'] = np.zeros(data1['4b. close (USD)'].size)  
for i in range(data['4a. close (USD)'].size - 7):
    #data['target'][i] = (-data['5. adjusted close'][i] + ((data['5. adjusted close'][i + 7] +  data['5. adjusted close'][i + 6] +  data['5. adjusted close'][i + 5]+  data['5. adjusted close'][i + 4]+  data['5. adjusted close'][i + 3]+  data['5. adjusted close'][i + 2]+  data['5. adjusted close'][i + 1]) / 7)  ) / data['5. adjusted close'][i]
    data['target'][i] = (-data['4b. close (USD)'][i] + data['4b. close (USD)'][i + 7]   ) / data['4b. close (USD)'][i]
    data['target'][i] = data['target'][i] *100
def trend(x):
    if x > 4:        
        return 1
    elif x < -4:        
        return -1
    else:
        return 0
data['target']= data['target'].apply(lambda x:trend(x))

data = data.drop(columns=['1a. open (USD)','1b. open (USD)','2a. high (USD)','2b. high (USD)','3a. low (USD)','3b. low (USD)', '4a. close (USD)','6. market cap (USD)'])

data = data.drop(columns=['4b. close (USD)', '5. volume'])

sns.set(font_scale = 1)
df1 = pd.melt(data, data.columns[-1], data.columns[:-1])


g = sns.FacetGrid( df1, col="variable", hue="target", col_wrap=4,height=2.5,sharex=False,sharey=False)
g.map(sns.kdeplot, "value", shade=True)

plt.show()

plt.figure(figsize=(12, 12))
heatmap = sns.heatmap(data.corr(), vmin=-1, vmax=1, annot=True, cmap='BrBG')
heatmap.set_title('Correlation Heatmap', fontdict={'fontsize':18}, pad=12);

target = data['target']
data = data.drop(columns=['adx','obv','target'])
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
# transform data
data = pd.DataFrame(scaler.fit_transform(data),columns = data.columns)
X_train, X_test, y_train, y_test = train_test_split(data, target, test_size=0.25)

from sklearn.model_selection import KFold
from sklearn.model_selection import cross_val_score
k_fold = KFold(n_splits=5, shuffle=True, random_state=0)

from sklearn.linear_model import LogisticRegression
clf = LogisticRegression(penalty='l2', C=1)
scoring = 'accuracy'
score = cross_val_score(clf, X_train, y_train, cv=k_fold, n_jobs=1, scoring=scoring)
print(score)
print(round(np.mean(score)*100, 2))

clf.fit(X_train, y_train)
Y_pred = clf.predict(X_test)
print('The accuracy is',accuracy_score(y_test,Y_pred))